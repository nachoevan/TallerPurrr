---
title: "\\textbf{Menos for, más purrr}:  \n Programación funcional con R"
author: "Nacho Evangelista"
date: "18 de febrero de 2020"
output: 
  beamer_presentation:
    keep_tex: FALSE
    slide_level: 3
    latex_engine: xelatex
    template: template_beamer.tex
    toc: true
    theme: "frankfurt"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, results = 'markup', comment="")
knitr::knit_hooks$set(source = function(x, options) {
    paste("\\begin{lstlisting}[style=codechunk]\n", paste(x,collapse = "\n"), 
      "\n\\end{lstlisting}", sep = '')
})
knitr::knit_hooks$set(output = function(x, options) {
  return(paste("\\small\n\\begin{verbatim}\n", x, "\\end{verbatim}\n\\normalsize", sep = ""))
})
```

```{r, warning=FALSE, message=FALSE}
library(dplyr)
library(purrr)
library(tidyr)
library(ggplot2)
options(tibble.print_max = 10)
```


# Introducción

## Motivación

### A


- Nuestro objetivo: reemplazar los _for loops_ o estructuras de repetición. Los lenguajes de programación puramente funcionales utilizan funciones para lograr los mismos resultados.

- En R base existen las funciones de la familia \texttt{apply}. En el paquete \texttt{purrr}, estas funciones se reemplazan por la familia \texttt{map}, más fáciles de usar. Se llaman funcionales: reciben una función como argumento.

- En una estructura funcional, no es necesario crear una lista vacía para ir guardando resultados, el código es más conciso.

- Premisa: arrancar con porciones de código pequeños y fáciles de entender (funciones). Combinar estos bloques en estructuras más complejas.

- Evitar duplicación de código. La duplicación hace que los errores y _bugs_ sean más frecuentes. También se hace más difícil modificar el código.

- Principio: no repetirse a uno mismo (DRY: _don't repeat yourself_)

- R programmers prefer to solve this type of problem by applying an operation to each element in a vector. This often requires only one line of code, with no appeal to indices.

- Estilo funcional: descomponer un problema grande en partes y resolver cada una de estas partes con una función o combinación de funciones.

- El estilo funcional permite obtener soluciones eficientes y elegantes a problemas modernos

## Listas en R

### Listas

- El bloque fundamental de \texttt{purrr} son las listas:
  - Un vector es un objeto que guarda elementos individuales del mismo tipo
  - Un dataframe es una estructura que guarda varios vectores de la misma longitud pero de distinto tipo.
  - Una lista es una estructura que permite guardar objetos de distinto tipo y longitud.


- https://cran.r-project.org/web/packages/listviewer/index.html

# purrr

## La función \texttt{map}

### A

- Muchas operaciones de R simplemente funcionan en forma vectorizada; cuando proveemos vectores como entrada, la función se aplica elemento a elemento (una suerte de iteración)

- Muchas funciones no tienen esa capacidad

- \texttt{purrr} sirve para iterar

- La función (funcional) más básica de \texttt{purrr} es \texttt{map}: toma un vector y una función, y aplica la función a cada elemento del vector, devolviendo los resultados en una lista.

- \texttt{map(1:3,f)} es equivalente a \texttt{list(f(1), f(2), f(3))}


## Acomodando el tipo de salida

### A


## Funciones anónimas

### A 


## Múltiples argumentos

### \texttt{map2}

## dataframes

### Pero yo nunca usé listas...

# purrr + tidyr + dplyr



## Columnas lista y dataframes anidados

- Some crazy stuff starts happening when you learn that tibble columns can be lists (as opposed to vectors, which is what they usually are).

- For instance, a tibble can be “nested” where the tibble is essentially split into separate data frames based on a grouping variable, and these separate data frames are stored as entries of a list 

### ¿Cómo se construyen?

- En la definición del \texttt{tibble}
- Usando \texttt{groupby} y \texttt{nest}
- Como resultado de una operación.

### I. En la definición del \texttt{tibble}

```{r}

```


### II. Usando \texttt{nest}

```{r}

```


### III. Como resultado de una operación {.fragile}

\small Queremos unir estas dos tablas reemplazando los códigos del casting por los personajes.

```{r ejemplo-separarfilas-1, echo = TRUE}
peleas <- tibble::tribble(
 ~pelea, ~horario,                      ~casting,
      1,  "20:30",        "gsf901,fez195,yfm179",
      2,  "20:50",               "thf028,yfm179",
      3,  "19:40", "jfa348,fez195,gky651,wpx281",
      4,  "21:00",               "thf028,fez195")
```

```{r ejemplo-separarfilas-2, echo = TRUE}
luchadores <- tibble::tribble(
   ~codigo,           ~nombre,
  "gsf901",  "Vicente Viloni",
  "thf028",     "Hip Hop Man",
  "wpx281",         "La Masa",
  "fez195", "Fulgencio Mejía",
  "jfa348",        "Mc Floyd",
  "phb625",     "Mario Morán",
  "gky651",      "Rulo Verde",
  "yfm179",    "Steve Murphy")
```

### {.fragile}

```{r ejemplo-separarfilas-3, echo = TRUE}
peleas %>%
  mutate(casting_split = strsplit(casting, split = ",")) %>%
  select(-horario,-casting) %>%
  unnest(casting_split) %>%
  left_join(luchadores, by = c("casting_split" = "codigo"))
```


## \texttt{mutate} + \texttt{purrr}

### ¿Por qué necesito purrr? {.fragile}

```{r, eval=FALSE}
tibble(list_col = list(c(1, 5, 7), 
                       5, 
                       c(10, 10, 11))) %>%
  mutate(list_sum = sum(list_col))
```

```{r, eval = FALSE}
tibble(list_col = list(c(1, 5, 7), 
                       5, 
                       c(10, 10, 11))) %>%
  mutate(list_sum = map(list_col, sum))
```

## Ejemplos

### 1. Identificar el mes {.fragile}

Queremos obtener el número de mes a partir de la abreviatura

```{r, echo = TRUE}
datos <- tibble::tribble(
 ~id,~dia,  ~mes, ~año,
   1,  15, "Sep", 2019,
   2,   6, "oct", 2021,
   3,   3, "Ene", 2020,
   4,  31, "dic", 2019)
```

### {.fragile}

Idea

1. Armar un vector con las abreviaturas de los meses
2. Usar la función \texttt{which} junto con \texttt{map}

```{r, echo=TRUE}
meses <- c("Ene","Feb","Mar","Abr","May","Jun",
           "Jul","Ago","Sep","Oct","Nov","Dic")
```

```{r, echo=TRUE}
which(meses=="Sep")
```

```{r, echo=TRUE}
which(meses==c("Sep","Ene"))
```

### {.fragile}

```{r echo = TRUE}
datos %>%
  mutate(mes_n = map(mes,~which(meses==.x)))
```

### {.fragile}

```{r echo = TRUE}
datos %>%
  mutate(mes_n = map(mes,~which(toupper(meses)==toupper(.x))))
```

### {.fragile}

```{r echo = TRUE}
datos %>%
  mutate(mes_n = map_int(mes,~which(toupper(meses)==toupper(.x))))
```

### 2. Secuencia de fechas {.fragile}

Contamos con los movimientos de dos empresas. Interesa tener la serie temporal de eventos para cada empresa y producto. 

```{r ejemplofechas1, echo = TRUE}
datos <- tibble::tribble(
  ~empresa, ~producto,       ~fecha, ~evento,
       "A",      "A1", "02/06/2018",     112,
       "A",      "A1", "06/06/2018",     141,
       "A",      "A1", "13/07/2018",     119,
       "A",      "A2", "01/05/2018",      53,
       "A",      "A2", "04/05/2018",      67,
       "B",      "B1", "01/07/2018",     127,
       "B",      "B1", "05/07/2018",     301,
       "B",      "B1", "10/07/2018",      98,
       "B",      "B1", "11/07/2018",     167)
datos$fecha <- as.Date(datos$fecha,format = "%d/%m/%Y")
```

###

Idea:

1. Determinar la primera y última fecha de cada grupo
2. Generar una secuencia de fechas (\texttt{seq.Date}) para cada grupo y construir una tabla con todas las fechas
3. Unir esta tabla con la original

### {.fragile}

```{r ejemplo-fechas-2, echo = TRUE}
fechas_todas <- 
  datos %>%
  group_by(empresa, producto) %>%
  summarise(fecha_inicial = min(fecha),
            fecha_final = max(fecha)) %>%
  mutate(fechas = map2(fecha_inicial,
                       fecha_final,
                       ~seq.Date(.x,.y,by="1 day"))) %>%
  select(-fecha_inicial,-fecha_final)
```

### {.fragile}

```{r ejemplo-fechas-3, echo = TRUE}
fechas_todas %>%
  unnest(fechas) %>%
  left_join(datos, by = c("empresa","producto","fechas" = "fecha"))
```


### 3. Abrir varios archivos a la vez {.fragile}

En el directorio de trabajo hay varios archivos que debemos abrir y leer.

```{r ejemplo-abrirarchivos-1, echo = TRUE}
list.files(pattern="archivo")
```
Idea:

1. Listar los archivos y construir un \texttt{tibble}
2. Leer cada archivo con \texttt{read.csv}
3. _Desanidar_

### {.fragile}

```{r ejemplo-abrirarchivos-2, echo = TRUE}
list.files(pattern="archivo") %>%
  tibble(archivos = .) %>%
  mutate(contenido = map(archivos,read.csv)) %>%
  unnest(contenido)
```


### 4. Múltiples salidas {.fragile}

Queremos analizar frases de canciones y determinar: a) cantidad de palabras, b) cantidad de preposiciones
 
```{r ejemplo-multiplessalidas-1, echo = FALSE}
datos <- tibble::tribble(
               ~banda,                     ~cancion,                                                           ~frase,
    "Los Wachiturros",          "Este es el pasito",                               "El que no hace palmas es un gato",
            "La Base",             "Sabor sabrosón",      "Según la moraleja, el que no hace palmas se deja, se deja",
       "Damas Gratis",           "Me va a extrañar",                          "ATR perro cumbia cajeteala piola gato",
    "Altos Cumbieros",            "No voy a llorar",       "Andy, fijate que volvieron, quienes… los altos cumbieros",
  "Los Pibes Chorros", "Llegamos los Pibes Chorros", "Llegamos los pibes chorros queremos las manos de todos arriba…",
            "La Liga",               "Se re pudrió",                       "El que no hace palmas tiene fama de gato",
       "Los Palmeras",                    "La cola",    "A la una, a la dos, a la one two three four five seven nine")
```

```{r ejemplo-multiplessalidas-2}
options(width = 60)
datos
```

###

Idea:

1. Definir una función que devuelva ambas cantidades
2. Aplicarla a cada frase

### {.fragile}

```{r ejemplo-multiplessalidas-3, echo=TRUE}
analizar_frase <- function(cancion){
  preposiciones <- c("a", "ante", "bajo", "cabe", "con", 
                     "contra", "de", "desde", "durante", 
                     "en", "entre", "hacia", "hasta", "mediante", 
                     "para", "por", "según", "sin", "so", "sobre", 
                     "tras", "versus", "vía")
  
  palabras <- strsplit(cancion," ") %>% unlist
  
  cant_palabras <- length(palabras)
  
  cant_preposiciones <- sum(palabras %in% preposiciones)
  
  return(list(cant_palabras = cant_palabras,
              cant_preposiciones = cant_preposiciones))
  }
```

### {.fragile}

```{r ejemplo-multiplessalidas-4, echo = TRUE, eval = FALSE}
datos %>%
  mutate(resultado = map(frase,analizar_frase)) %>%
  unnest_wider(resultado)
```

```{r ejemplo-multiplessalidas-5, echo = FALSE}
options(width = 60)
datos %>%
  mutate(resultado = map(frase,analizar_frase)) %>%
  unnest_wider(resultado)
```


### 5. Múltiples plots {.fragile}

Queremos construir un conjunto de plots mostrando los ajustes de polinomios de distinto orden a los puntos del dataset.

```{r ejemplo-multiplesplots-1, echo = TRUE}
datos <- tibble::tribble(
 ~`x`,  ~`y`,
  211,   184,
  230,   147,
  587,   413,
  414,   252,
  419,   252,
  157,   272,
  327,   158,
  222,   158,
  451,   249,
  296,   127)
```

###

Idea:

1. Combinamos los datos con cada uno de los posibles órdenes del polinomio
2. \texttt{group by} + \texttt{nest}
3. Aplicar una función que cree el gráfico utilizando \texttt{map}

### {.fragile}

```{r ejemplo-multiplesplots-2, echo=TRUE}
plots <- crossing(poly = 1:6, datos) %>%
  nest(datos = !poly) %>%
  ungroup() %>%
  mutate(plot = map2(datos, poly,
                     function(data, poly) {
                       ggplot(data, aes(x = x, y = y)) +
                         geom_point() +
                         stat_smooth(
                           method = "lm", se = FALSE,
                           formula = y ~ poly(x, poly, raw = TRUE),
                           colour = "maroon1") + 
                         theme_minimal()
                     }))
```

### {.fragile}
```{r ejemplo-multiplesplots-3, echo=FALSE}
plots
```


### {.fragile}
```{r ejemplo-multiplesplots-4, echo=TRUE, fig.height=4}
library(patchwork)
plots$plot[[1]] + plots$plot[[6]]
```

### 6. K-fold cross validation {.fragile}

```{r}
K <- 4
data <- mtcars %>% 
  mutate(fold = rep(1:K,length.out=nrow(.))) %>% 
  arrange(fold) %>%
  group_by(fold) %>%
  nest() %>%
  mutate(dummy = 1)
```

```{r}
train_test <- data %>% 
  inner_join(data, by="dummy") %>%
  select(-dummy) %>%
  filter(fold.y != fold.x) %>%
  group_by(fold.x) %>%
  summarise(test = first(data.x),
            train = list(bind_rows(data.y)))
```

```{r}
train_test %>%
  mutate(modelo = map(train,~lm(mpg ~ wt,data=.x)),
         pred = map2(modelo,test,~predict(.x,.y)),
         real = map(test,"mpg"))
```

# Extra

## Más de dos argumentos pmap

## Puede fallar...

### \texttt{possibly}

## \texttt{repeat}

# Resumen

### Resumen